/* tslint:disable */
/* eslint-disable */
/**
 * Tachyon API
 * Tachyon Platform REST API
 *
 * The version of the OpenAPI document: 0.49.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
/**
 * User-defined tool definition sent via the API request.
 * 
 * Uses JSON Schema format compatible with OpenAI/Anthropic
 * function calling. Tool definitions are passed to the LLM
 * alongside server built-in tools so the model can decide
 * when to invoke them.
 * 
 * # Example
 * 
 * ```json
 * {
 *   "name": "query_database",
 *   "description": "Run a read-only SQL query",
 *   "parameters": {
 *     "type": "object",
 *     "properties": {
 *       "sql": { "type": "string" }
 *     },
 *     "required": ["sql"]
 *   },
 *   "fire_and_forget": false
 * }
 * ```
 * @export
 * @interface ClientToolDefinition
 */
export interface ClientToolDefinition {
    /**
     * Human-readable description shown to the LLM so it
     * can decide when to call this tool.
     * @type {string}
     * @memberof ClientToolDefinition
     */
    description: string;
    /**
     * When `true`, the server dispatches the tool call to
     * the client and immediately returns a success message
     * to the LLM without waiting for a result submission.
     * The client still receives the `tool_call_pending` SSE
     * event but does not need to call the tool-result
     * endpoint. Useful for notifications, webhooks, logging,
     * and other side-effect-only operations.
     * @type {boolean}
     * @memberof ClientToolDefinition
     */
    fireAndForget?: boolean;
    /**
     * Unique tool name. Must not collide with server
     * built-in tools (e.g. `read_file`, `execute_command`,
     * `search_files`). Use descriptive, snake_case names.
     * @type {string}
     * @memberof ClientToolDefinition
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof ClientToolDefinition
     */
    parameters: any | null;
}

/**
 * Check if a given object implements the ClientToolDefinition interface.
 */
export function instanceOfClientToolDefinition(value: object): value is ClientToolDefinition {
    if (!('description' in value) || value['description'] === undefined) return false;
    if (!('name' in value) || value['name'] === undefined) return false;
    if (!('parameters' in value) || value['parameters'] === undefined) return false;
    return true;
}

export function ClientToolDefinitionFromJSON(json: any): ClientToolDefinition {
    return ClientToolDefinitionFromJSONTyped(json, false);
}

export function ClientToolDefinitionFromJSONTyped(json: any, ignoreDiscriminator: boolean): ClientToolDefinition {
    if (json == null) {
        return json;
    }
    return {
        
        'description': json['description'],
        'fireAndForget': json['fire_and_forget'] == null ? undefined : json['fire_and_forget'],
        'name': json['name'],
        'parameters': json['parameters'],
    };
}

export function ClientToolDefinitionToJSON(json: any): ClientToolDefinition {
    return ClientToolDefinitionToJSONTyped(json, false);
}

export function ClientToolDefinitionToJSONTyped(value?: ClientToolDefinition | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }

    return {
        
        'description': value['description'],
        'fire_and_forget': value['fireAndForget'],
        'name': value['name'],
        'parameters': value['parameters'],
    };
}

